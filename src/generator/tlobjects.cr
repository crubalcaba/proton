require "tl_parser"
require "./source_builder"

module Proton
  module Generator
    class TLObjects
      HEADER = <<-CRYSTAL
      # Copyright 2020 - Chris Watson <cawatson1993@gmail.com>
      #
      # You should have received with this program a copy of the MIT license. This code is
      # subject to the terms and conditions outlined in said license. For more information,
      # please see https://en.wikipedia.org/wiki/MIT_License.
      #
      # This file was autogenerated. Please do not modify directory.
      CRYSTAL

      AUTO_CASTS = {
        "InputPeer" => "Utils.get_input_peer(client.get_input_entity({}))",
        "InputChannel" => "Utils.get_input_channel(client.get_input_entity({}))",
        "InputUser" => "Utils.get_input_user(client.get_input_entity({}))",
        "InputDialogPeer" => "client.get_input_dialog({})",
        "InputNotifyPeer" => "client.get_input_notify({})",
        "InputMedia" => "Utils.get_input_media({})",
        "InputPhoto" => "Utils.get_input_photo({})",
        "InputMessage" => "Utils.get_input_message({})",
        "InputDocument" => "Utils.get_input_document({})",
        "InputChatPhoto" => "Utils.get_input_chat_photo({})",
      }

      NAMED_AUTO_CASTS = {
        "chat_id,int": "client.get_peer_id({}, add_mark: false)",
      }

      NAMED_BLACKLIST = Set.new(["messages.discardEncryption"])

      PATCHED_TYPES = {
        message: "Message",
        message_empty: "Message",
        message_service: "Message",
      }

      PRIMITIVE_SUPER_CLASSES = ["Bool", "True", "Error", "Null"]

      # [Types|Functions] => Namespace => []TLParser::Definition
      @definitions : Hash(String, Hash(String, Array(TLParser::Definition)))

      def initialize(sources : Array(String))
        @definitions = build_definitions(sources)
      end

      def generate_types(outdir : String, namespace : Array(String) = [] of String)
        definitions = @definitions["Types"]

        definitions.each do |ns, tlobjects|
          ns = ns.downcase

          # Find all primitives (types with no subclass)
          primitives = tlobjects.select { |o| PRIMITIVE_SUPER_CLASSES.includes?(o.type.name) }
          tlobjects -= primitives

          # Get names of all classes
          class_names = tlobjects.map { |o| make_class_name(o.name) }

          # Find all super classes
          super_classes = tlobjects.reduce(Set(String).new) do |acc, o|
            acc << o.type.name unless class_names.includes?(o.type.name)
            acc
          end.to_a

          # Figure out file name
          filename = ns.empty? ? File.join(outdir, "types.cr") : File.join(outdir, "types/#{ns}.cr")

          # Create directory
          directory = File.join(outdir, "types")
          Dir.mkdir_p(directory)

          # Write the file
          write_file(filename, namespace) do |builder|
            # primitives.each { |pr| write_primitive(builder, pr) }

            super_classes.each_with_index do |sc, i|
              write_superclass(builder, sc)
              builder.writeln
            end

            tlobjects.each_with_index do |tlo, i|
              write_tlobject(builder, tlo)
              builder.writeln if i < tlobjects.size - 1
            end
          end
        end
      end

      def generate_functions(outdir : String, namespace : Array(String) = [] of String)
      end

      private def write_file(filename, namespace, &block)
        output = File.open(filename, mode: "w+")
        output.rewind

        builder = SourceBuilder.new(output)

        path = Path.new(filename)
        builder.writeln HEADER

        if ["types.cr", "functions.cr"].includes?(path.parts.last)
          builder.writeln("require \"../helpers\"")
          builder.writeln("require \"../tl_object\"")
          builder.writeln
        else
          builder.writeln("require \"../../helpers\"")
          builder.writeln("require \"../../tl_object\"")
          builder.writeln
        end

        namespace.each do |ns|
          builder.writeln "module #{ns}"
        end

        yield builder

        namespace.each do |ns|
          builder.writeln "end"
        end

        output.close
      end

      private def write_primitive(builder, type)
        clsname = make_class_name(type.name)
        supername = superlcass_name(type)

        builder.writeln "class #{clsname} < #{supername}"
        builder.writeln "end"
      end

      private def write_superclass(builder, type)
        clsname = make_class_name(type)

        builder.writeln "abstract class #{clsname} < TLObject"

        builder.writeln "end"
      end

      private def write_tlobject(builder, type)
        clsname = make_class_name(type.name)
        supername = superlcass_name(type)
        constructor_id = "0x" + type.id.to_s(16).rjust(8, '0')

        builder.writeln "class #{clsname} < #{supername}"
        builder.writeln("getter constructor_id = #{constructor_id}_u32")
        builder.writeln

        unless type.params.empty?
          write_param_props(builder, type.params)
          builder.writeln
          write_initializer(builder, type.params)
          builder.writeln
        end

        write_to_bytes(builder, type.params)
        builder.writeln
        write_from_bytes(builder, type.params)

        builder.writeln("end")
      end

      private def build_definitions(sources)
        sources.reduce({} of String => Hash(String, Array(TLParser::Definition))) do |acc, d|
          acc["Types"] ||= {} of String => Array(TLParser::Definition)
          acc["Functions"] ||= {} of String => Array(TLParser::Definition)

          defs = TLParser.parse(d)
          defs.each do |x|
            cat = x[0].to_s
            de = x[1]
            ns = de.namespace.join(".")
            acc[cat][ns] ||= [] of TLParser::Definition
            acc[cat][ns] << de
          end

          acc
        end
      end

      private def make_class_name(name)
        name.split('_').join(&.camelcase)
      end

      private def superlcass_name(obj)
        subclass = make_class_name(obj.type.name)
        if ["Bool", "True", "Error", "Null"].includes?(subclass) ||
            subclass.downcase == obj.name.downcase
          subclass = "TLObject"
        end
        subclass
      end

      private def to_crystal_type(param)
        case param.name
        when "int"
          "Int32"
        when "long"
          "Int64"
        when "int128"
          "Int128"
        when "int256"
          "BigInt"
        when "double"
          "Float64"
        when "bytes"
          "Bytes"
        when "string"
          "String"
        when "true"
          "Bool"
        when "date"
          "Time"
        when "Vector", "vector"
          "Array(#{to_crystal_type(param.generic_arg.not_nil!)})"
        else
          param.name
        end
      end

      private def write_param_props(builder, params)
        params = sort_params(params)
        params.each do |p|
          type = p.type
          if type.is_a?(TLParser::NormalParam)
            cr_type = to_crystal_type(p.type.as(TLParser::NormalParam).type)
            builder.write("property #{p.name} : #{cr_type}")
            if flag = type.flag
              builder.write("?")
            end
            builder.writeln
          end
        end
      end

      private def write_to_bytes(builder, params)
        builder.writeln("def to_bytes")
        builder.writeln("buffer = IO::Memory.new")
        builder.writeln("buffer.write_bytes(self.constructor_id, IO::ByteFormat::LittleEndian)")

        params = params.select { |p| p.type.is_a?(TLParser::NormalParam) }
        flags = params.select { |p| p.type.as(TLParser::NormalParam).flag }

        flags.each do |flag|
          type = flag.type.as(TLParser::NormalParam)
          builder.writeln "buffer.write_byte(@#{flag.name} ? #{type.flag.not_nil!.index} : 0)"
        end

        params.each do |param|
          self.write_arg_to_bytes(builder, param)
        end

        builder.writeln("buffer")
        builder.writeln("end")
      end

      private def write_arg_to_bytes(builder, arg)
        type = arg.type.as(TLParser::NormalParam)
        flag = type.flag
        type = type.type
        cr_type = self.to_crystal_type(type)

        # Do nothing, this only specifies a later type
        return if type.generic_ref

        pp arg
        puts

        case type.name
        when "vector", "Vector"
          if type.name == "Vector"
            builder.writeln("buffer.write_bytes(0x15c4b51c_u32, IO::ByteFormat::LittleEndian)")
          end
          builder.writeln("buffer.write_bytes(@#{arg.name}.size, IO::ByteFormat::LittleEndian)")
          builder.writeln("@#{arg.name}.each do |val|")
          builder.writeln("builder.write(val.to_bytes)")
          builder.writeln("end")
        when "string", "bytes"
          builder.writeln("buffer.write(TLObject.serialize_bytes(@#{arg.name})")
        when "date"
          builder.writeln("buffer.write(TLObject.serialize_datetime(@#{arg.name})")
        when "int", "long", "int128", "double"
          builder.writeln("buffer.write_bytes(@#{arg.name}, IO::ByteFormat::LittleEndian)")
        when "true"
          # These are actually NOT written! Only used for flags
        else
          # Else it may be a custom type
          builder.write("buffer.write(@#{arg.name}.to_bytes)")

          # If the type is not boxed (i.e. starts with lowercase) we should
          # not serialize the constructor ID (so remove its first 4 bytes).
          unless arg.name[0].ascii_lowercase?
            builder.write("[4, -1]")
          end

          builder.writeln
        end
      end

      private def write_from_bytes(builder, params)
        builder.writeln("def self.from_bytes(bytes)")

        builder.writeln("end")
      end

      def write_initializer(builder, params)
        params = sort_params(params)
        unless params.empty?
          builder.writeln "def initialize("
          params.each_with_index do |p, i|
            write_param(builder, p)
            builder.writeln(i < (params.size - 1) ? "," : "")
          end
          builder.dedent
          builder.writeln ")"
          builder.indent
          builder.writeln("end")
        end
      end

      private def write_param(builder, param)
        type = param.type.as(TLParser::NormalParam)
        cr_type = to_crystal_type(type.type)
        builder.write("@#{param.name} : #{cr_type}")
        if flag = type.flag
          cr_type == "Bool" ? builder.write(" = false") : builder.write("? = nil")
        end
      end

      private def sort_params(params)
        params
          .select(&.type.is_a?(TLParser::NormalParam))
          # .reject(&.type.as(TLParser::NormalParam).flag)
          .sort do |a, b|
            a_type = a.type.as(TLParser::NormalParam)
            b_type = b.type.as(TLParser::NormalParam)

            a_index = a_type.flag ? a_type.flag.not_nil!.index + 1 : 0
            b_index = b_type.flag ? b_type.flag.not_nil!.index + 1 : 0

            a_index <=> b_index
          end
      end
    end
  end
end

api_data = File.read(File.expand_path("./data/api.tl", __DIR__))
mtproto_data = File.read(File.expand_path("./data/mtproto.tl", __DIR__))

generator = Proton::Generator::TLObjects.new([api_data, mtproto_data])
generator.generate_types(File.expand_path("../proton/tl", __DIR__), ["Proton", "TL"])
